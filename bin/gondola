#!/usr/bin/env ruby

# Gondola - gondola
# Main executable file which will dish out projects in parallel
# after converting them as needed

require 'rubygems'
require 'yaml'
require 'cmdparse'

lib_dir = File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib/'))
$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)

require 'gondola'

# Command parsing stuff
cmd = CmdParse::CommandParser.new(true, true)
cmd.program_name = "gondola"
cmd.program_version = Gondola::VERSION
cmd.add_command(CmdParse::HelpCommand.new)
cmd.add_command(CmdParse::VersionCommand.new)

# Run command
class RunCommand < CmdParse::Command
  def initialize
    super('run', false)
    @opts = {}
    self.short_desc = "Run an entire test suite or one test case"
    # User supplied options for running a suite
    self.options = CmdParse::OptionParserWrapper.new do |opt|
      opt.on('-s', '--super_parallel', 'Execute all test cases at once') do |sp|
        @opts[:super_parallel] = true
      end
      opt.on('-r', '--recursive', 'Execute all sub suites') do |r|
        @opts[:recursive] = true
      end
    end
  end

  # Proper usage format
  def usage
    "Usage: #{commandparser.program_name} run [options] [tests]"
  end

  # Function that is executed when a user issues a run command
  def execute(args)
    if args.length < 1
      puts usage
      exit 1
    end
    # Can either provide directory or file
    runner = Gondola::TestRunner.new
    args.each do |t| 
      if File.exists? t
        runner.add_test t
      else
        puts "Could not find \"#{t}\""
      end
    end
    runner.run(@opts)
    puts
    runner.results.each do |r|
      puts "Sauce Labs ID: #{r[:id]}"
      puts "Test Name: #{r[:name]}"
      puts "Browser: #{r[:browser]}"
      if r[:result] == "OK"
        puts "Test Passed"
      else
        puts "Test Failed - #{r[:result].size} error(s)"
        r[:result].each_with_index do |e,i|
          puts "- Error #{i+1}:"
          puts "    Selenese Command: #{e[:command][:original]}" if e[:command][:original]
          puts "    Ruby Command: #{e[:command][:ruby]}" if e[:command][:ruby]
          puts "    #{e[:error]}"
        end
      end
      puts
    end
  end
end
cmd.add_command(RunCommand.new)

cmd.parse
exit(0)
