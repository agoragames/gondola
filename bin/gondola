#!/usr/bin/env ruby

# Gondola - gondola
# Main executable file which will dish out projects in parallel
# after converting them as needed

require 'rubygems'
require 'yaml'
require 'cmdparse'

lib_dir = File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib/'))
$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)

require 'gondola'

# Command parsing stuff
cmd = CmdParse::CommandParser.new(true, true)
cmd.program_name = "gondola"
cmd.program_version = Gondola::VERSION
cmd.add_command(CmdParse::HelpCommand.new)
cmd.add_command(CmdParse::VersionCommand.new)

# Run command
class RunCommand < CmdParse::Command
  def initialize
    super('run', false)
    @opts = {}
    @quiet = false
    self.short_desc = "Run an entire test suite or one test case"
    # User supplied options for running a suite
    self.options = CmdParse::OptionParserWrapper.new do |opt|
      opt.on('-r', '--recursive', 'Execute all sub suites') do |r|
        @opts[:recursive] = true
      end
      opt.on('-q', '--quiet', 'Execute quietly') do |q|
        @quiet = true
      end
    end
  end

  # Proper usage format
  def usage
    "Usage: #{commandparser.program_name} run [options] [tests]"
  end

  # Observer function to watch the progress of runs
  def update(result)
    bs = ""
    result[:browser].each_value { |v| bs = bs + "#{v} " }
    if result[:status] == :in_progress
      puts "#{result[:id]}: Started test \"#{result[:name]}\" with #{bs}"
    else
      num = result[:errors].size
      puts "#{result[:id]}: \"#{result[:name]}\" with #{bs}has completed with #{num} errors"
    end
  end
    
  # Parse and print results in an organized manner
  def report(results)
    puts
    @runner.results.each do |r|
      puts "Sauce Labs ID : #{r[:id]}"
      puts "Test Name     : #{r[:name]}"
      bs = ""
      r[:browser].each_value { |v| bs = bs + "#{v} " }
      puts "Browser       : #{bs}"
      if r[:status] == :passed
        puts "Status        : Test Passed"
      else
        puts "Status        : Test Failed - #{r[:errors].size} error(s)"
        r[:errors].each_with_index do |e,i|
          puts "- Error #{i+1}, Command number #{e[:cmd_num]}:"
          max_key = 0
          e[:command].each_key { |k| max_key = k.size if k.size > max_key }
          max_key = -1 * (max_key + 8)
          e[:command].each_pair do |k,v| 
            puts "    %1$*2$s : #{v}" % [ "#{k.capitalize} command", max_key ]
          end
          puts "    #{e[:error]}"
        end
      end
      puts
    end
  end

  # Function that is executed when a user issues a run command
  def execute(args)
    if args.length < 1
      puts usage
      exit 1
    end
    # Can either provide directory or file
    runner = Gondola::SuiteRunner.new
    runner.add_observer(self) unless @quiet
    args.each do |t| 
      if File.exists? t
        runner.add_test t
      else
        puts "Could not find \"#{t}\""
      end
    end
    puts "Contacting Sauce Labs, please wait..." unless @quiet
    runner.run(@opts)
    report(runner.results) unless @quiet
  end
end
cmd.add_command(RunCommand.new)

cmd.parse
exit(0)
